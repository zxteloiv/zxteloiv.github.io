<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- common.css -->
  <style>* {-webkit-tap-highlight-color: rgba(0,0,0,0);}html {-webkit-text-size-adjust: none;}body {font-family: Arial, Helvetica, sans-serif;margin: 0;color: #333;word-wrap: break-word;}h1, h2, h3, h4, h5, h6 {line-height: 1.1;}img {max-width: 100% !important;}blockquote {margin: 0;padding: 0 15px;color: #777;border-left: 4px solid #ddd;}hr {background-color: #ddd;border: 0;height: 1px;margin: 15px 0;}code {font-family: Menlo, Consolas, 'Ubuntu Mono', Monaco, 'source-code-pro', monospace;line-height: 1.4;margin: 0;padding: 0.2em 0;font-size: 85%;background-color: rgba(0,0,0,0.04);border-radius: 3px;}pre > code {margin: 0;padding: 0;font-size: 100%;word-break: normal;background: transparent;border: 0;}ol {list-style-type: decimal;}ol ol, ul ol {list-style-type: lower-latin;}ol ol ol, ul ol ol, ul ul ol, ol ul ol {list-style-type: lower-roman;}table {border-spacing: 0;border-collapse: collapse;margin-top: 0;margin-bottom: 16px;}table th {font-weight: bold;}table th, table td {padding: 6px 13px;border: 1px solid #ddd;}table tr {border-top: 1px solid #ccc;}table tr:nth-child(even) {background-color: #f8f8f8;}input[type="checkbox"] {cursor: default;margin-right: 0.5em;font-size: 13px;}.task-list-item {list-style-type: none;}.task-list-item+.task-list-item {margin-top: 3px;}.task-list-item input {float: left;margin: 0.3em 1em 0.25em -1.6em;vertical-align: middle;}#tag-field {margin: 8px 2px 10px;}#tag-field .tag {display: inline-block;background: #cadff3;border-radius: 4px;padding: 1px 8px;color: black;font-size: 12px;margin-right: 10px;line-height: 1.4;}</style>
  <!-- ace-static.css -->
  <style>.ace_static_highlight {white-space: pre-wrap;}.ace_static_highlight .ace_gutter {width: 2em;text-align: right;padding: 0 3px 0 0;margin-right: 3px;}.ace_static_highlight.ace_show_gutter .ace_line {padding-left: 2.6em;}.ace_static_highlight .ace_line {position: relative;}.ace_static_highlight .ace_gutter-cell {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;user-select: none;top: 0;bottom: 0;left: 0;position: absolute;}.ace_static_highlight .ace_gutter-cell:before {content: counter(ace_line, decimal);counter-increment: ace_line;}.ace_static_highlight {counter-reset: ace_line;}</style>
  <style>.ace-chrome .ace_gutter {background: #ebebeb;color: #333;overflow : hidden;}.ace-chrome .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-chrome {background-color: #FFFFFF;color: black;}.ace-chrome .ace_cursor {color: black;}.ace-chrome .ace_invisible {color: rgb(191, 191, 191);}.ace-chrome .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-chrome .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-chrome .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-chrome .ace_invalid {background-color: rgb(153, 0, 0);color: white;}.ace-chrome .ace_fold {}.ace-chrome .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-chrome .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-chrome .ace_support.ace_type,.ace-chrome .ace_support.ace_class.ace-chrome .ace_support.ace_other {color: rgb(109, 121, 222);}.ace-chrome .ace_variable.ace_parameter {font-style:italic;color:#FD971F;}.ace-chrome .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-chrome .ace_comment {color: #236e24;}.ace-chrome .ace_comment.ace_doc {color: #236e24;}.ace-chrome .ace_comment.ace_doc.ace_tag {color: #236e24;}.ace-chrome .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-chrome .ace_variable {color: rgb(49, 132, 149);}.ace-chrome .ace_xml-pe {color: rgb(104, 104, 91);}.ace-chrome .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-chrome .ace_heading {color: rgb(12, 7, 255);}.ace-chrome .ace_list {color:rgb(185, 6, 144);}.ace-chrome .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-chrome .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-chrome .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-chrome .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-chrome .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-chrome .ace_gutter-active-line {background-color : #dcdcdc;}.ace-chrome .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-chrome .ace_storage,.ace-chrome .ace_keyword,.ace-chrome .ace_meta.ace_tag {color: rgb(147, 15, 128);}.ace-chrome .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-chrome .ace_string {color: #1A1AA6;}.ace-chrome .ace_entity.ace_other.ace_attribute-name {color: #994409;}.ace-chrome .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}</style>
  <!-- export.css -->
  <style>
    body{margin:0 auto;max-width:800px;line-height:1.4}
    #nav{margin:5px 0 10px;font-size:15px}
    #titlearea{border-bottom:1px solid #ccc;font-size:17px;padding:10px 0;}
    #contentarea{font-size:15px;margin:16px 0}
    .cell{outline:0;min-height:20px;margin:5px 0;padding:5px 0;}
    .code-cell{font-family:Menlo,Consolas,'Ubuntu Mono',Monaco,'source-code-pro',monospace;font-size:12px;}
    .latex-cell{white-space:pre-wrap;}
  </style>
  <!-- User CSS -->
  <style> .text-cell {font-size: 15px;}.code-cell {font-size: 12px;}.markdown-cell {font-size: 15px;}.latex-cell {font-size: 15px;}</style>
</head>
<body>
  <div id="nav"><div>Next: <a href='character model.html'>character model</a>, Previous: <a href='entity-linking.html'>entity-linking</a>, Up: <a href='index.html'>Index</a></div></div>
  <div id="titlearea">
    <h2>Deep Learning for NLP survey</h2>
  </div>
  <div id="contentarea"><div class="cell markdown-cell"><p><a href="http://nlp.stanford.edu/courses/NAACL2013/">http://nlp.stanford.edu/courses/NAACL2013/</a></p>
<h1 id="deep-learning-for-natural-language-processing-without-magic-">Deep Learning for Natural Language Processing (without Magic)</h1>
<p>A tutorial given at <a href="http://naacl2013.naacl.org/">NAACL HLT    2013</a>. Based on an earlier tutorial given at     <a href="http://www.acl2012.org">ACL 2012</a> by Richard Socher, Yoshua Bengio, and    Christopher Manning.</p>
<p>By <a href="http://www.socher.org/">Richard Socher</a> and   <a href="http://nlp.stanford.edu/%7Emanning/">Christopher Manning</a></p>
<h2 id="slides">Slides</h2>
<p><a href="http://nlp.stanford.edu/courses/NAACL2013/NAACL2013-Socher-Manning-DeepLearning.pdf">NAACL2013-Socher-Manning-DeepLearning.pdf</a>       (24MB) - 205 slides.</p>
<h2 id="videos">Videos</h2>
<p><a href="http://techtalks.tv/talks/deep-learning-for-nlp-without-magic-part-1/58414/">Part 1</a></p>
<p><a href="http://techtalks.tv/talks/deep-learning-for-nlp-without-magic-part-2/58415/">Part 2</a></p>
<p><em>Sorry, Flash videos only.</em> ☹</p>
<h2 id="abstract">Abstract</h2>
<p>Machine learning is everywhere in today's NLP, but by and large  machine learning amounts to numerical optimization of weights for  human designed representations and features. The goal of deep  learning is to explore how computers can take advantage of data to  develop features and representations appropriate for complex  interpretation tasks. This tutorial aims to cover the basic  motivation, ideas, models and learning algorithms in deep learning  for natural language processing. Recently, these methods have been  shown to perform very well on various NLP tasks such as language  modeling, POS tagging, named entity recognition, sentiment analysis  and paraphrase detection, among others. The most attractive quality  of these techniques is that they can perform well without any  external hand-designed resources or time-intensive feature  engineering. Despite these advantages, many researchers in NLP are  not familiar with these methods. Our focus is on insight and  understanding, using graphical illustrations and simple, intuitive  derivations. The goal of the tutorial is to make the inner workings  of these techniques transparent, intuitive and their results  interpretable, rather than black boxes labeled "magic here". The  first part of the tutorial presents the basics of neural networks,  neural word vectors, several simple models based on local windows and  the math and algorithms of training via backpropagation. In this  section applications include language modeling and POS tagging. In  the second section we present recursive neural networks which can  learn structured tree outputs as well as vector representations for  phrases and sentences. We cover both equations as well as  applications. We show how training can be achieved by a modified  version of the backpropagation algorithm introduced before. These  modifications allow the algorithm to work on tree  structures. Applications include sentiment analysis and paraphrase  detection. We also draw connections to recent work in semantic  compositionality in vector spaces. The principle goal, again, is to  make these methods appear intuitive and interpretable rather than  mathematically confusing. By this point in the tutorial, the audience  members should have a clear understanding of how to build a deep  learning system for word-, sentence- and document-level tasks. The  last part of the tutorial gives a general overview of the different  applications of deep learning in NLP, including bag of words  models. We will provide a discussion of NLP-oriented issues in  modeling, interpretation, representational power, and optimization.</p>
<h2 id="outline">Outline</h2>
<ol>
<li>The Basics<ol>
<li>Motivations</li><li>From logistic regression to neural networks</li><li>Word representations</li><li>Unsupervised word vector learning</li><li>Backpropagation Training</li><li>Learning word-level classifiers: POS and NER</li><li>Sharing statistical strength</li></ol>
</li><li>Recursive Neural Networks<ol>
<li>Motivation</li><li>Recursive Neural Networks for Parsing</li><li>Optimization and Backpropagation Through Structure</li><li>Compositional Vector Grammars: Parsing</li><li>Recursive Autoencoders: Paraphrase Detection</li><li>Matrix-Vector RNNs: Relation classification</li><li>Recursive Neural Tensor Networks: Sentiment Analysis</li></ol>
</li><li>Applications, Discussion, and Resources<ol>
<li>Assorted Speech and NLP applications</li><li>Deep Learning: General Strategy and Tricks</li><li>Resources (readings, code, …)</li><li>Discussion</li></ol>
</li></ol>
<h2 id="references">References</h2>
<p><a href="http://nlp.stanford.edu/%7Esocherr/DeepLearning-ACL2012-tutorial.pdf">All       references we referred to in one pdf file</a></p>
<h2 id="further-information">Further Information</h2>
<ul>
<li>A very useful assignment for getting started with deep learning    in NLP is to implement a simple window-based NER tagger in this    exercise we designed for the <a href="http://cs224n.stanford.edu/">Stanford NLP class cs224N</a>.     The zip file    includes starter code in Java and the pdf walks through all the    steps:<a href="http://nlp.stanford.edu/%7Esocherr/pa4_ner.pdf">http://nlp.stanford.edu/~socherr/pa4_ner.pdf</a><a href="http://nlp.stanford.edu/%7Esocherr/pa4-ner.zip">http://nlp.stanford.edu/~socherr/pa4-ner.zip</a></li><li>The implementation assignment for a sparse    autoencoder can be found here: <a href="http://nlp.stanford.edu/%7Esocherr/sparseAutoencoder_2011new.pdf">exercise description pdf</a> and <a href="http://nlp.stanford.edu/%7Esocherr/sparseae_exercise.zip">matlab starter code</a> (11MB)</li><li><a href="http://deeplearning.net/tutorial/">The    most extensive and thorough tutorial</a> for deep learning in     general is available at the     <a href="http://deeplearning.net/">deeplearning.net</a> site (using Theano, a Python library, from Yoshua    Bengio's group, which has its own <a href="http://deeplearning.net/software/theano/tutorial/">tutorial</a>)</li><li>Another     <a href="http://deeplearning.stanford.edu/wiki/index.php/UFLDL_Tutorial">introductory tutorial</a> from Stanford, which also    includes     <a href="http://deeplearning.stanford.edu/wiki/index.php/Exercise:Sparse_Autoencoder">pointers to the implementation    assignment for a sparse autoencoder</a></li><li>A hands-on tutorial for denoising autoencoders can be found    at <a href="http://deeplearning.net/tutorial/dA.html#daa">http://deeplearning.net/tutorial/dA.html#daa</a></li><li>Charles Elkan wrote a great, detailed derivation of recursive    neural networks: <a href="http://cseweb.ucsd.edu/%7Eelkan/250B/learningmeaning.pdf">http://cseweb.ucsd.edu/~elkan/250B/learningmeaning.pdf</a></li><li>You can study clean recursive neural network code with    backpropagation through structure on this    page: <a href="http://www.socher.org/index.php/Main/ParsingNaturalScenesAndNaturalLanguageWithRecursiveNeuralNetworks">Parsing    Natural Scenes And Natural Language With Recursive Neural    Networks</a></li><li>Learn about    <a href="http://nlp.stanford.edu/projects/DeepLearningInNaturalLanguageProcessing.shtml">Deep      Learning for Natural Language Processing</a> research from the     <a href="http://nlp.stanford.edu">Stanford NLP Group</a></li></ul>
</div></div>
  <script>document.body.onkeyup = function(e) {
if (e.keyCode === 39) window.location.href = 'character model.html';
if (e.keyCode === 37) window.location.href = 'entity-linking.html';
}</script>
</body>
</html>